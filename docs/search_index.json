[["index.html", "Location Quality Chapter 1 Introduction 1.1 Project Overview 1.2 Loading Dataset", " Location Quality Doug Rose 2023-12-08 Chapter 1 Introduction 1.1 Project Overview The past decade so has brought an explosion of new developments in MLB player evaluation. With Statcast technology generating massive amounts of data related to ball movement tracking, baseball fans now have a clearer understanding of how metrics like release speed, spin rate, horizontal and vertical pitch movement impact the quality of a pitch thrown by a pitcher. Websites like Baseball Savant and Fangraphs offer a wealth information on any MLB pitcher covering batted ball results, effectiveness of pitch arsenal, profiling of each pitch type’s velocity, pitch movement, spin rate etc. There is certainly no shortage of available analytics related to MLB players in 2023. In my search for emerging baseball metrics attempting to paint a full picture of how good a pitcher is or how good an individual pitch is, I’ve found that one piece of the puzzle seems to be missing: pitch level location quality. Some metrics exist that effectively detail generally how good they are at locating pitches like BB%, FIP (Fielding Independent Pitching) to name a few. I have yet to come across a metric that evaluates pitchers on the basis of how good are the locations they throw their pitches in. The Baseball savant website includes player dashboards with distributions of a pitcher’s pitches in terms of location zone type regions. Zone types being heart, shadow, chase, waste. Though comparing pitchers on how their distribution of zone type regions isn’t so straightforward. One might assume that an ideal pitch location would be in the shadow region, so pitchers with the higher rate of shadow region should be the best at locating their pitches. But what if a pitch is thrown in a shadow region on a 3-0 count? And if that pitch is technically outside the strike zone, is it really a better location than a 3-0 pitch located in the heart of the plate? Furthermore, you would expect the pitch type to factor into the quality of the location. Is a 4-seam fastball thrown at the top of the strike zone in a 2-0 count really the same location quality as a curveball thrown in the same location in a 2-0 count? If you have enough of an understanding of baseball you’d conclude that no, these two pitches are not equal in terms of their location. My aim in this project is to create a pitch-level metric that evaluates the quality of an individual pitch’s location. Several factors influence the metric including: the horizontal distance from the plate as the ball passes the plate (plate_x), the vertical height of the ball from the ground as it passes the plate (plate_z), the pitch type thrown (4-seam fastball, sinker, slider, curveball etc.), and the hitter count the pitch is thrown in (0-1, 2-2, 3-2 etc.) We can visualize the output and compare pitches under different sets of conditions to see what actually are ideal pitch locations given a set of circumstances and what locations are less than ideal. Finally these output can be applied to pitches thrown in previous seasons by particular players so we can effectively compare players on how effective they are at locating pitches. Let’s get started. 1.2 Loading Dataset We’ll start by loading in Statcast data from the 2014 MLB season through the 2023 season, hosted on the baseball savant website. Each records represents a single pitch and every single pitch contains a wealth of information (93 fields). This code reads in each years worth of pitches (roughly 710,000 pitches per year) stored locally. To reproduce the following scripts for the rest of the project, each season’s worth of data will need to be scraped and stored with the scripts included in the github folder. rm(list = ls()) mlbraw2014 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2014.csv&quot;,show_col_types=0) mlbraw2015 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2015.csv&quot;,show_col_types=0) mlbraw2016 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2016.csv&quot;,show_col_types=0) mlbraw2017 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2017.csv&quot;,show_col_types=0) mlbraw2018 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2018.csv&quot;,show_col_types=0) mlbraw2019 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2019.csv&quot;,show_col_types=0) mlbraw2020 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2020.csv&quot;,show_col_types=0) mlbraw2021 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2021.csv&quot;,show_col_types=0) mlbraw2022 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2022.csv&quot;,show_col_types=0) mlbraw2023 &lt;- read_csv(&quot;/Users/dougrose/Desktop/location/raw_statcast/mlbraw2023.csv&quot;,show_col_types=0) ## New names: ## • `` -&gt; `...8` Format the game_date column to ensure all years have the same format. mlbraw2014$game_date &lt;- as.Date(mlbraw2014$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2015$game_date &lt;- as.Date(mlbraw2015$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2016$game_date &lt;- as.Date(mlbraw2016$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2017$game_date &lt;- as.Date(mlbraw2017$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2018$game_date &lt;- as.Date(mlbraw2018$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2019$game_date &lt;- as.Date(mlbraw2019$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2020$game_date &lt;- as.Date(mlbraw2020$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2021$game_date &lt;- as.Date(mlbraw2021$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2022$game_date &lt;- as.Date(mlbraw2022$game_date, format=&quot;%m/%d/%y&quot;) mlbraw2023$game_date &lt;- as.Date(mlbraw2023$game_date, format=&quot;%m/%d/%y&quot;) Create a single data frame containing all years and remove individual year data frames. mlbraw &lt;- bind_rows(mlbraw2014, mlbraw2015, mlbraw2016, mlbraw2017, mlbraw2018, mlbraw2019, mlbraw2020, mlbraw2021, mlbraw2022, mlbraw2023) mlbraw &lt;- mlbraw %&gt;% arrange(desc(game_year), desc(game_date), game_pk) rm(mlbraw2014, mlbraw2015, mlbraw2016, mlbraw2017, mlbraw2018, mlbraw2019, mlbraw2020, mlbraw2021, mlbraw2022, mlbraw2023) "],["cleaning-validating-transforming.html", "Chapter 2 Cleaning, Validating, Transforming 2.1 Explain Variables of Interest 2.2 Create New Variables 2.3 Validating Count, Handedness, Game Year 2.4 Remove and Transform Event Values 2.5 Event Outcome Frequency by Count 2.6 Average Delta Run Expectancy 2.7 Join Lookup Table To Main Data 2.8 Addressing Pitch Types 2.9 Cleaning Pitch Locations 2.10 Count of All Observations", " Chapter 2 Cleaning, Validating, Transforming 2.1 Explain Variables of Interest With a single data frame containing all MLB pitches the past 10 years, I’ll start to limit it to only the variables relevant to the project. game_year: simply the year the game was played pitch_name: name of the pitch type thrown by the pitcher (Fastball, Curveball etc.) pitch_type: abbreviated pitch_name (FF represents a 4-Seam Fastball) p_throws: does the pitcher throw right-handed or left-handed stand: does the batter stand right-handed or left-handed balls: how many balls were in the count before the pitch of record strikes: how many strikes were in the count before the pitch of record events: what event took place as a result of this pitch (single, walk, hit by pitch, home run) plate_x: the horizontal location of the pitch as its crossing the plate, measured in feet away from the center of the plate plate_z: the vertical location of the pitch as its crossing the plate, measured in feet off the ground 2.2 Create New Variables The final data set will be a cleaned version of mlbraw containing columns: year, p_type, count, hand, events, plate_x, plate_z, lw. First I’ll start by creating single column detailing the outcome of an individual pitch (each row). The events column only displays a value if that pitch leads to a batter outcome (walk, single, etc.). NA values represent pitches made that don’t end the at-bats, like balls and strikes. So this new events column details the result of every pitch. Also, I’ll want to combine the strikes and balls values creating a new count column. This represents the batter’s count state each pitch occurs in. The stand column specifies whether the batter hits right-handed or left-handed. The p_throws column specifies whether the pitcher throws right-handed or left-handed. For the purposes or this project I’m interested in the combination of the batter/pitcher handedness. The new column hand details this. mlbraw &lt;- mlbraw %&gt;% mutate(events = if_else(is.na(events) | events == &quot;&quot;, type, events)) %&gt;% mutate(events = if_else(events == &quot;B&quot;, &quot;ball&quot;, if_else(events == &quot;S&quot;, &quot;strike&quot;, events))) %&gt;% mutate(count = paste(balls, strikes, sep=&quot;-&quot;)) %&gt;% mutate(hand = paste(p_throws, stand, sep = &quot;v&quot;)) mlbraw &lt;- mlbraw %&gt;% select(game_year, hand, count, pitch_type, pitch_name, events, plate_x, plate_z, delta_run_exp) A batter’s count can only be one of 12 possible counts so I’ll filter the data removing impossible counts. And also filter out impossible events in particular counts. (ex. A batter can’t draw a walk in a 2-2 count) mlbraw &lt;- mlbraw %&gt;% filter(count %in% c(&quot;0-0&quot;,&quot;0-1&quot;,&quot;0-2&quot;,&quot;1-0&quot;,&quot;1-1&quot;,&quot;1-2&quot;, &quot;2-0&quot;,&quot;2-1&quot;,&quot;2-2&quot;,&quot;3-0&quot;,&quot;3-1&quot;,&quot;3-2&quot;)) mlbraw &lt;- mlbraw %&gt;% filter(!(count == &quot;3-2&quot; &amp; events == &quot;ball&quot;)) %&gt;% filter(!(count == &quot;3-1&quot; &amp; events == &quot;ball&quot;)) %&gt;% filter(!(count == &quot;2-2&quot; &amp; events == &quot;walk&quot;)) %&gt;% filter(!(count == &quot;2-1&quot; &amp; events == &quot;walk&quot;)) Change the data type of these variables to factors limiting the possible values and setting orders. mlbraw$count &lt;- factor(mlbraw$count, levels=c(&quot;0-0&quot;,&quot;0-1&quot;,&quot;0-2&quot;,&quot;1-0&quot;,&quot;1-1&quot;,&quot;1-2&quot;, &quot;2-0&quot;,&quot;2-1&quot;,&quot;2-2&quot;,&quot;3-0&quot;,&quot;3-1&quot;,&quot;3-2&quot;)) mlbraw$hand &lt;- factor(mlbraw$hand, levels=c(&quot;RvR&quot;, &quot;RvL&quot;, &quot;LvR&quot;, &quot;LvL&quot;)) mlbraw$game_year &lt;- factor(mlbraw$game_year, levels=c(&quot;2014&quot;,&quot;2015&quot;,&quot;2016&quot;,&quot;2017&quot;, &quot;2018&quot;,&quot;2019&quot;,&quot;2020&quot;,&quot;2021&quot;, &quot;2022&quot;,&quot;2023&quot;)) Finally, I’ll remove rows with NA values in our columns of interest. mlbraw &lt;- mlbraw %&gt;% filter(!is.na(game_year), !is.na(hand), !is.na(count), !is.na(pitch_type), !is.na(pitch_name), !is.na(events), !is.na(plate_x), !is.na(plate_z), !is.na(delta_run_exp)) 2.3 Validating Count, Handedness, Game Year plot1 &lt;- mlbraw %&gt;% group_by(count) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(p= n/ sum(n)) %&gt;% select(-n) ggplot(data=plot1, aes(x=p, y=fct_rev(count)))+ geom_col(fill=&quot;steelblue3&quot;) + geom_text(aes(label = paste(100*round(p,2), &quot;%&quot;, sep=&quot;&quot;)), hjust = 1.1, size=4, color=&quot;white&quot;, fontface=&quot;bold&quot;)+ ggtitle(&quot;Batter Count distribution \\n&quot;)+ theme_minimal()+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), axis.text=element_text(size=12), axis.text.x = element_blank(), axis.text.y = element_text(hjust=1), axis.ticks.x = element_blank(), axis.title = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size=20, hjust = 0.5))+ xlim(0,0.27)+ coord_cartesian(xlim = c(0, 0.27), expand = FALSE) The graph above shows the distribution of batter counts. Here I can start to get an idea of how much data there is to work with to build a location metric. 0-0 counts are well accounted for making up 26% of all pitches, while pitches in 3 ball counts are more scarce. plot2 &lt;- mlbraw %&gt;% group_by(hand) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(p= n/ sum(n)) %&gt;% select(-n) ggplot(data=plot2, aes(x=p, y=reorder(hand,p)))+ geom_col(fill=&quot;steelblue3&quot;) + geom_text(aes(label = paste(100*round(p,2), &quot;%&quot;, sep=&quot;&quot;)), hjust = 1.3, size=4, color=&quot;white&quot;, fontface=&quot;bold&quot;)+ ggtitle(&quot;Pitcher and Batter Handedness distribution \\n&quot;) + theme_minimal()+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), axis.text=element_text(size=12), axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title = element_blank(), #axis.text.x = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size=20, hjust = 0.5))+ xlim(0,0.43)+ coord_cartesian(xlim = c(0, 0.4), expand = FALSE) plot3 &lt;- mlbraw %&gt;% group_by(game_year) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(p= n/ sum(n)) %&gt;% select(-n) ggplot(data=plot3, aes(x=p, y=game_year))+ geom_col(fill=&quot;steelblue3&quot;) + geom_text(aes(label = paste(100*round(p,2), &quot;%&quot;, sep=&quot;&quot;)), hjust = 1.3, size=4, color=&quot;white&quot;, fontface=&quot;bold&quot;)+ ggtitle(&quot;Pitcher and Batter Handedness distribution \\n&quot;) + theme_minimal()+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), axis.text=element_text(size=12), axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title = element_blank(), #axis.text.x = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size=20, hjust = 0.5))+ xlim(0,0.43)+ coord_cartesian(xlim = c(0, 0.15), expand = FALSE) As expected, the data set is split pretty evenly by game year. Teams plays 162 regular season games per year, giving me about 2400 games worth of data per year. The only exception is the 60 game 2020 season due to COVID-19. 2.4 Remove and Transform Event Values The events column may contain some other game event description not related to the pitch being thrown. If the pitcher picks off the runner leading off first base, that event will show up as a record in the data set. If a coach argues in between pitches and gets ejected from the game, that event will show up as a record in the data set. For the purpose of this project, I am only concerned with pitches thrown, and specifically competitive pitches where legitimate attempts are made by the batter. This is a somewhat subjective criteria, but I’ve chosen to limit the data set and remove the following events. mlbraw &lt;- mlbraw %&gt;% filter(!(events %in% c(&quot;catcher_interf&quot;,&quot;caught_stealing_2b&quot;,&quot;caught_stealing_3b&quot;, &quot;caught_stealing_home&quot;,&quot;ejection&quot;,&quot;field_error&quot;,&quot;game_advisory&quot;, &quot;intent_walk&quot;,&quot;other_out&quot;,&quot;passed_ball&quot;,&quot;pickoff_1b&quot;, &quot;pickoff_2b&quot;,&quot;pickoff_3b&quot;,&quot;pickoff_caught_stealing_2b&quot;, &quot;pickoff_caught_stealing_3b&quot;,&quot;pickoff_caught_stealing_home&quot;, &quot;pickoff_error_2b&quot;,&quot;pickoff_error_3b&quot;,&quot;pitchout&quot;, &quot;runner_double_play&quot;,&quot;stolen_base_2b&quot;,&quot;stolen_base_3b&quot;, &quot;stolen_base_3b&quot;,&quot;stolen_base_home&quot;))) Wild pitches are showing up as a unique events in the data set, when in reality they are just balls thrown extremely away from the strike zone. I’ve changed the wild_pitch values to ball or walk depending on the count it was thrown in. mlbraw_a &lt;- mlbraw %&gt;% filter(count %in% c(&quot;0-0&quot;,&quot;0-1&quot;,&quot;1-0&quot;,&quot;1-1&quot;,&quot;2-0&quot;,&quot;2-1&quot;,&quot;0-2&quot;,&quot;1-2&quot;,&quot;2-2&quot;)) mlbraw_b &lt;- mlbraw %&gt;% filter(count %in% c(&quot;3-0&quot;,&quot;3-1&quot;,&quot;3-2&quot;)) mlbraw_a &lt;- mlbraw_a %&gt;% mutate(events = if_else(events ==&quot;wild_pitch&quot;, &quot;ball&quot;, events)) mlbraw_b &lt;- mlbraw_b %&gt;% mutate(events = if_else(events ==&quot;wild_pitch&quot;, &quot;walk&quot;, events)) mlbraw &lt;- bind_rows(mlbraw_a, mlbraw_b) %&gt;% arrange(game_year, count, events) rm(mlbraw_a, mlbraw_b) Similarly, foul balls in two strike counts should be labeled foul rather than strike. A strike thrown in a 0-2, 1-2, 2-2, or 3-2 count would actually be a strikeout. So whenever a batter fouls a ball off in a these counts, I’ll given the event a new value: foul. mlbraw_a &lt;- mlbraw %&gt;% filter(count %in% c(&quot;0-2&quot;,&quot;1-2&quot;,&quot;2-2&quot;,&quot;3-2&quot;)) mlbraw_b &lt;- mlbraw %&gt;% filter(!(count %in% c(&quot;0-2&quot;,&quot;1-2&quot;,&quot;2-2&quot;,&quot;3-2&quot;))) mlbraw_a &lt;- mlbraw_a %&gt;% mutate(events = if_else(events == &quot;strike&quot;, &quot;foul&quot;, events)) mlbraw &lt;- bind_rows(mlbraw_a, mlbraw_b) rm(mlbraw_a, mlbraw_b) mlbraw &lt;- mlbraw %&gt;% mutate(events=if_else(events==&quot;home_run&quot;,&quot;hr&quot;,events)) I’ll separate the event values as non_outs and outs for future purposes. And check to make sure these are the distinct events values contained in the main data set. non_outs &lt;- c(&quot;ball&quot;,&quot;double&quot;,&quot;hit_by_pitch&quot;,&quot;hr&quot;, &quot;foul&quot;,&quot;single&quot;, &quot;strike&quot;,&quot;triple&quot;,&quot;walk&quot;,&quot;wild_pitch&quot;) outs &lt;- c(&quot;double_play&quot;,&quot;field_out&quot;,&quot;fielders_choice&quot;,&quot;fielders_choice_out&quot;, &quot;force_out&quot;, &quot;grounded_into_double_play&quot;,&quot;fielders_choice_out&quot;, &quot;sac_bunt&quot;,&quot;sac_bunt_double_play&quot;,&quot;sac_fly&quot;,&quot;sac_fly_double_play&quot;, &quot;strikeout&quot;,&quot;strikeout_double_play&quot;,&quot;triple_play&quot;) mlbraw %&gt;% select(events) %&gt;% filter(!(events %in% non_outs)) %&gt;% filter(!(events %in% outs)) # shouldn&#39;t return any records ## # A tibble: 0 × 1 ## # ℹ 1 variable: events &lt;chr&gt; I’ll assign the value out to all the different events resulting in an out rather than using their description. Limiting the possible event values will be essential for the steps going forward. mlbraw &lt;- mlbraw %&gt;% mutate(events = if_else(events %in% outs, &quot;out&quot;, events)) Reorder the factor levels for plotting purposes. mlbraw$events &lt;-factor(mlbraw$events, levels=c(&quot;strike&quot;,&quot;foul&quot;,&quot;ball&quot;,&quot;walk&quot;,&quot;hit_by_pitch&quot;, &quot;out&quot;,&quot;single&quot;,&quot;double&quot;,&quot;triple&quot;,&quot;hr&quot;)) 2.5 Event Outcome Frequency by Count plot4 &lt;- inner_join(mlbraw %&gt;% group_by(count,events) %&gt;% count(), mlbraw %&gt;% group_by(count) %&gt;% count(), join_by(count)) %&gt;% mutate(p = n.x / n.y) %&gt;% select(count, events, p) %&gt;% filter(events != &quot;hit_by_pitch&quot;) ggplot(plot4)+ geom_col(aes(x=events, y=p), fill=&quot;grey&quot;,width=0.9, show.legend = FALSE)+ geom_hline(yintercept=0, linewidth=0.1)+ theme_bw()+ ylim(0, 0.63)+ facet_wrap(~count, ncol=3, nrow=4, scales=&quot;free&quot;)+ ggtitle(&quot;Event Outcome Frequency by Count \\n&quot;)+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), strip.text = element_text(size=20), axis.text=element_text(size=16), axis.text.x = element_text(angle = 45, hjust = 1, size=14,color=&quot;grey40&quot;), axis.title = element_blank(), plot.title = element_text(size=20, hjust = 0.5), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) The plot above breaks down the frequency of events in different batter counts, specifically when the events have been narrowed down to 10 values. A pitcher is much more likely to throw a strike in a 3-0 count than a 0-0 count or 0-2 count. And is much more likely to record an out in two-strike counts than no-strike or one-strike counts. Glancing over the plot, the results appear to be what I’d expect which gives some validation to the contents of the data set. 2.6 Average Delta Run Expectancy The purpose of this project is to quantify how good or bad a pitch location is based on the pitch type, count, handedness of the pitch and batter, and of course the location of the pitch on x and y plane. But what metric should be used quantify and formulate the results. The column delta_run_exp exists in the data frame that specifies the value of that individual event in terms of how the run expectancy changed based on that individual event. Every fixed situation in a game has an run expectancy based on where base runners are located prior to the pitch, number of outs prior to the pitch, and the batter count prior to the pitch. Let’s look at an example scenario. An at-bat begins with 0 outs and runners on 1st and 2nd starting in a 0-0 count. In this particular state there is an expected number of runs scored for the remainder of the inning based on those parameters. In 2023, on average 1.465 runs scored in the remainder of the inning for that specific scenario. If the first pitch thrown in the at-bat is a strike, we have a new scenario with a different expected runs scored for the remainder of the inning. Now there are 0 outs with runners on 1st and 2nd in a 0-1 count. And now the average runs scored for the remained of the inning is slightly different than before: 1.376. So the strike thrown by the pitcher changed the expected runs scored by -0.089 and will display that vlaue in the delta_run_exp column. Every pitch in a baseball game can be evaluated by comparing the expected runs prior to the pitch thrown to the expected runs after the pitch is thrown. This appears to be best measure available to apply to my location quality metric using the delta_run_exp value to quality the result of any pitch. The only problem is that delta_run_exp derives it’s value from: count, outs, base runners, and resulting event. In my project I aim to evaluate pitches on different conditions. Really, I am just looking for the average change in run expectancy based on the count and event. So the goal here is to transform the existing data set so rather than relying on delta_run_exp as our metric of success/fail, we create a new variable that gives a change in run expectancy based on the parameters we have set for this project. So when a specific event takes place (ball, strike, double, fielders choice etc.) in a specific count (0-1, 2-0, 3-2 etc.) we have the average change in run expectancy. re_outs &lt;- mlbraw %&gt;% filter(events == &quot;out&quot;) %&gt;% group_by(count, events) %&gt;% summarise(re = round(mean(delta_run_exp, na.rm = TRUE), 4), .groups = &#39;drop&#39;) re_non_outs &lt;- mlbraw %&gt;% filter(events %in% non_outs) %&gt;% group_by(count, events) %&gt;% summarise(re = round(mean(delta_run_exp, na.rm = TRUE), 4), .groups = &#39;drop&#39;) re_lookup &lt;- bind_rows(re_outs, re_non_outs) %&gt;% arrange(count, events) rm(outs, non_outs, re_outs, re_non_outs) Treat every event that resulted in an out as a single out event (regardless of the type of out or how many outs resulted in the play), this is meant to neutralize the affect base runners have on the changing run expectancy as well as the effect of number of outs. I’ve separated outs from non_outs and aggregated to find the average change in run expectancy for every possible event in every possible count. anti_join(mlbraw %&gt;% distinct(count, events), re_lookup %&gt;% distinct(count, events), join_by(count, events)) ## # A tibble: 0 × 2 ## # ℹ 2 variables: count &lt;fct&gt;, events &lt;fct&gt; With the clean mlbraw data set and linear weights look up table, we check to if any combination of count and events from the two data sets are not compatible No combination of count and events exist in one table that is not in the other. Finally, if a pitch resulted in a hit by pitch I’ve decided to treat the event as if it were a ball. And in effect, take the change in run expectancy from ball rather than hit_by_pitch. This leads to more continuity between location plots where rare hit_by_pitch events aren’t strongly influencing certain locations and throwing off the remaining areas. mlbraw_a &lt;- mlbraw %&gt;% filter(count %in% c(&quot;0-0&quot;,&quot;0-1&quot;,&quot;1-0&quot;,&quot;1-1&quot;,&quot;2-0&quot;,&quot;2-1&quot;,&quot;0-2&quot;,&quot;1-2&quot;,&quot;2-2&quot;)) mlbraw_b &lt;- mlbraw %&gt;% filter(count %in% c(&quot;3-0&quot;,&quot;3-1&quot;,&quot;3-2&quot;)) mlbraw_a &lt;- mlbraw_a %&gt;% mutate(events = if_else(events == &quot;hit_by_pitch&quot;, &quot;ball&quot;, events)) mlbraw_b &lt;- mlbraw_b %&gt;% mutate(events = if_else(events == &quot;hit_by_pitch&quot;, &quot;walk&quot;, events)) mlbraw &lt;- bind_rows(mlbraw_a, mlbraw_b) %&gt;% arrange(game_year, count, events) rm(mlbraw_a, mlbraw_b) 2.7 Join Lookup Table To Main Data Now I’ll take the main data set with the past 10 years worth of pitches and join the look up table to it, essentially replacing the delta_run_exp values with my new average change in run expectancy values. mlbraw &lt;- mlbraw %&gt;% left_join(re_lookup, join_by(count, events)) %&gt;% select(-delta_run_exp) Here is an overview of how each event in each count impacts run expectancy. We now have a specific change in run expectancy value for every combination of count and events. plot5 &lt;- re_lookup %&gt;% filter(events != &quot;hit_by_pitch&quot;) plot5$events &lt;-factor(plot5$events, levels=c(&quot;out&quot;,&quot;strike&quot;,&quot;foul&quot;,&quot;ball&quot;,&quot;walk&quot;, &quot;single&quot;,&quot;double&quot;,&quot;triple&quot;,&quot;hr&quot;)) ggplot(data = plot5, aes(x=count, y=events, fill=re))+ geom_tile(color = &quot;black&quot;, show.legend = FALSE)+ geom_text(aes(x=count, y=events, label=round(re,2)), color = &quot;black&quot;, size = 4)+ ggtitle(&quot;Average Change in Run Expenctancy Based on Count and Events \\n&quot;)+ scale_fill_gradient2(high=&quot;red&quot;, mid=&quot;white&quot;, low=&quot;blue&quot;) + theme_void()+ theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 12, hjust = 1), axis.text.y = element_text(size = 12, hjust = 0.9), plot.title = element_text(size=20, hjust = 0.5))+ coord_fixed() As you might expect, event outcomes have slightly different run expectancy changes depending on the count. A home run hit in an 0-2 count has more added run value than a home run hit in a 3-0 count. This is because an 0-2 count is already a more favorable position for the pitcher to be in than a 3-0 count, with the run expectancy starting out lower before the home run is hit. Similarly, an out recorded in an 3-0 count is considerably more favorable to the pitcher than an out recorded in a 0-2 count. This makes logical sense to any baseball enthusiast. Thankfully, when comparing average change in run expectancy values by count we’re not seeing any drastic difference from one grouping to the other. And all the values appear to make a great deal of baseball sense. 2.8 Addressing Pitch Types So far in the cleaning process, we’ve avoided the pitch_type column. Here’s an overview at the pitch types make up a data set containing all pitches thrown the last 10 years in all MLB regular season game. plot6 &lt;- mlbraw %&gt;% group_by(pitch_type, pitch_name) %&gt;% count() %&gt;% arrange(desc(n)) ggplot(plot6, aes(x=n, y=reorder(pitch_name, n)))+ geom_col(fill=&quot;steelblue3&quot;)+ geom_text(aes(label = n), hjust = -0.1, size=4)+ ggtitle(&quot;Count of Observations by Pitch Type \\n&quot;)+ theme_minimal()+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), axis.text=element_text(size=12), axis.text.x = element_blank(), axis.text.y = element_text(hjust=1), axis.ticks.x = element_blank(), axis.title = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size=20, hjust = 0.5))+ xlim(0,2500000)+ coord_cartesian(expand = FALSE) 4-Seam Fastballs make up a major chunk of the data set. Sinkers, Sliders, Changeups, Curveballs, and cutters are well accounted for but a significant drop off in observations occurs for the remaining pitch types. For now, we will need to transform some of the pitch types. Some of the pitch type values are variations of Curveballs including: Knuckle Curves, Slow Curves, and Slurves. These pitch types do have their own distinct qualities and hand grip, but these are minor variations on the standard Curveball, especially when compared to other pitches. I’ll transform these Curveball variations so they take the standard Curveball pitch type value. Some pitch types are so rare compared to the 6 or so most commonly thrown pitches that for the purpose of this project they can be eliminated going forward. Screwballs, forkballs, euphus’, other will be removed. And Pitch Outs are not considered competitive pitches so they will be removed. Sweepers are a somewhat new pitch type gaining popularity and usage especially within the past year. They are similar to sliders in their movement but tend to have more horizontal break and less vertical break, and tend to have less velocity than sliders. Much debate has been made whether sweepers should be considering their own designated pitch type or as a variation of the slider. For purposes of this project due to the minimal observations, I will transform sweepers into sliders. mlbraw &lt;- mlbraw %&gt;% filter(pitch_type %in% c(&quot;FF&quot;,&quot;CU&quot;,&quot;SL&quot;,&quot;SI&quot;,&quot;CH&quot;,&quot;FS&quot;, &quot;FC&quot;,&quot;KC&quot;,&quot;ST&quot;,&quot;CS&quot;,&quot;SV&quot;)) mlbraw &lt;- mlbraw %&gt;% mutate(pitch_type = if_else(pitch_type %in% c(&quot;CU&quot;,&quot;CS&quot;,&quot;KC&quot;, &quot;SV&quot;), &quot;CU&quot;, if_else(pitch_type %in% c(&quot;CH&quot;,&quot;FS&quot;), &quot;CH&quot;, if_else(pitch_type %in% c(&quot;SL&quot;,&quot;ST&quot;), &quot;SL&quot;, pitch_type)))) %&gt;% mutate(pitch_name = if_else(pitch_type == &quot;CU&quot;, &quot;Curveball&quot;, pitch_name)) %&gt;% mutate(pitch_name = if_else(pitch_type == &quot;SL&quot;, &quot;Slider&quot;, pitch_name)) %&gt;% mutate(pitch_name = if_else(pitch_type == &quot;CH&quot;, &quot;Changeup&quot;, pitch_name)) plot7 &lt;- mlbraw %&gt;% group_by(pitch_name) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(s=sum(n)) %&gt;% mutate(p = n/s) ggplot(plot7, aes(x=p, y=reorder(pitch_name, p), label=p))+ geom_col(fill=&quot;steelblue3&quot;)+ geom_text(aes(label = paste(100*round(p,2), &quot;%&quot;, sep=&quot;&quot;)), hjust = 1.1, size=4, color=&quot;white&quot;, fontface=&quot;bold&quot;)+ ggtitle(&quot;Updated Count of Observations by Pitch Type \\n&quot;)+ theme_minimal()+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), axis.text=element_text(size=12), axis.text.x = element_blank(), axis.text.y = element_text(hjust=1), axis.ticks.x = element_blank(), axis.title = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size=20, hjust = 0.5))+ xlim(0,0.38)+ coord_cartesian(expand = FALSE) This leaves me with 6 pitch types to use to build the location quality metric with. 4-Seam Fastballs are much more well represented than the remaining pitch types, so we’ll see how this impacts the results going forward. mlbraw$pitch_type &lt;- factor(mlbraw$pitch_type, levels=c(&quot;FF&quot;,&quot;SI&quot;,&quot;FC&quot;,&quot;CH&quot;,&quot;CU&quot;,&quot;SL&quot;)) plot8 &lt;- inner_join(mlbraw %&gt;% group_by(pitch_type,events) %&gt;%count(), mlbraw %&gt;% group_by(pitch_type) %&gt;% count(), join_by(pitch_type)) %&gt;% mutate(p = n.x / n.y) %&gt;% select(pitch_type, events, p) plot8$pitch_type &lt;- factor(plot8$pitch_type, levels=c(&quot;FF&quot;,&quot;SI&quot;,&quot;FC&quot;,&quot;CH&quot;,&quot;CU&quot;,&quot;SL&quot;)) plot8$events &lt;- factor(plot8$events, levels=c(&quot;strike&quot;,&quot;foul&quot;,&quot;ball&quot;,&quot;walk&quot;,&quot;hit_by_pitch&quot;, &quot;out&quot;,&quot;single&quot;,&quot;double&quot;,&quot;triple&quot;,&quot;hr&quot;)) ggplot(plot8)+ geom_col(aes(x=events, y=p), fill=&quot;grey&quot;)+ ggtitle(&quot;Event Outcome Frequency by Pitch Type \\n&quot;)+ ylim(0, 0.4)+ theme_bw()+ facet_wrap(~pitch_type, ncol=3, nrow=3, scales=&quot;free&quot;)+ theme(strip.background = element_rect(fill = &quot;lightblue&quot;), strip.text = element_text(size=20), axis.text=element_text(size=16), axis.text.x = element_text(angle = 45, hjust = 1, size=14,color=&quot;grey40&quot;), axis.title = element_blank(), plot.title = element_text(size=20, hjust = 0.5), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) According to the graph above, event outcomes have generally the same frequency regardless of pitch type. Pitch types like curveballs, sliders, and changeups with more movement and aggressive hand grips are thrown for balls more often than strikes, while variations of fastballs are thrown for strikes more often. 2.9 Cleaning Pitch Locations Next, I’ll bring attention to the location of each pitch. Plate_x will take a value depending on how far away the pitch is horizontally from the center of the plate in feet If a pitch is thrown direction down the middle of the plate, its plate_x value will be 0. Home plate is 1.66 feet wide, so pitches with plate_x values ranging from -0.83 to 0.83 cross some part of the plate. Here is the distribution of plate_x values rounded up as whole number. mlbraw %&gt;% mutate(plate_x = round(plate_x,0)) %&gt;% group_by(plate_x) %&gt;% count() %&gt;% arrange(desc(plate_x)) %&gt;% regulartable() %&gt;% autofit() %&gt;% width(width=1) %&gt;% height(height=0.1) .cl-3d82cfe8{}.cl-3d7ef9b8{font-family:'Helvetica';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-3d808b5c{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-3d8095de{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3d8095e8{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3d8095fc{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}plate_xn928172665354492312,4922253,45911,631,07902,883,140-11,556,976-2241,665-311,448-4493-545-69-74-82-92-101-111 The plate_x pitch distribution is normal with an extremely high peak at 0. Pitches thrown more than 4 inches to the right or left of the center of the strike zone are extremely rare, so much so that I imagine data entry errors could be the reason for such extreme values. Regardless I’ve chosen to narrow the data set to only include pitches with plate_x values between -4 and 4. mlbraw &lt;- mlbraw %&gt;% filter(plate_x &gt;= -4, plate_x &lt;= 4) Turning attention to plate_z, a similar location distribution exists in the data set. The vast majority of pitches are thrown 2 or 3 feet above the ground (essentially the middle of the strike zone vertically). Pitches more than 6 feet above the ground are quite rare, as well as pitches 2 feet below the ground (bounced on before arriving). I’ll mark these heights as cutoffs and filter out pitches from the data set outside this range. mlbraw %&gt;% mutate(plate_z = round(plate_z,0)) %&gt;% group_by(plate_z) %&gt;% count() %&gt;% arrange(desc(plate_z)) %&gt;% regulartable() %&gt;% autofit() %&gt;% width(j=~plate_z,width=1) %&gt;% width(j=~n,width=1) .cl-3dd7f8e2{}.cl-3dd45df4{font-family:'Helvetica';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-3dd5e106{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-3dd5ea5c{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5edb8{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5edd6{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5edfe{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5ee12{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5ee30{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5ee4e{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5ee8a{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5eec6{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3dd5eee4{width:1in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}plate_zn12111210298821726064,339561,7764542,85632,002,21622,648,27911,102,7900204,405-121,991-21,925-3169-419-53 mlbraw &lt;- mlbraw %&gt;% filter(plate_z &gt;= -2, plate_z &lt;= 6) 2.10 Count of All Observations The challenge moving forward is evaluating the effectiveness of a pitch’s location when some combination of pitch type, count, and handedness is rare in the data set. 4-Seam Fastballs thrown by a RHP to a RHB in a 0-0 count is by far the most common situation making up 240,591 observations of the data set. While Curveballs thrown by LHP to LHB in 3-0 counts produce only 21 observations. How can 21 observations effectively map out pitch location quality? mlbraw &lt;- mlbraw %&gt;% rename(x=plate_x, y=plate_z) %&gt;% select(hand, pitch_type, count, events, x, y, re) plot9 &lt;- mlbraw %&gt;% group_by(hand, count, pitch_type) %&gt;% count() %&gt;% ungroup() ggplot(data = plot9, aes(x=pitch_type, y=count))+ geom_tile(aes(fill=n), alpha = 0.5,show.legend = FALSE)+ facet_wrap(~hand, scale=&quot;free&quot;)+ geom_text(aes(x=pitch_type, y=count, label=n))+ scale_fill_gradientn(colours = c(&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;), values = scales::rescale(c(min(plot9$n), quantile(plot9$n, 0.1), max(plot9$n))), guide=&quot;colorbar&quot;) + theme_void()+ theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 8, hjust = 1), axis.text.y = element_text(size = 12, hjust = 0.9), plot.title = element_text(size=20, hjust = 0.5)) To work around this challenge, I’ve decided to essentially double the data set. All pitches thrown by RHP to RHB will also include all pitches thrown by LHP to LHB with hand label LvL changed to RvR. The added data will have opposite plate_x values. So a pitch thrown by LHP to LHB with a plate_x of 1 and plate_z of 4 will be added as a pitch thrown by RHP to RHB with a plate_x of -1 and plate_z of 4. This mutation of data doubles the number of observations in the main data set. mlbraw_r_r &lt;- bind_rows(mlbraw %&gt;% filter(hand == &quot;RvR&quot;), mlbraw %&gt;% filter(hand == &quot;LvL&quot;) %&gt;% mutate(x = x*-1) %&gt;% mutate(hand = &quot;RvR&quot;)) mlbraw_l_l &lt;- bind_rows(mlbraw %&gt;% filter(hand == &quot;LvL&quot;), mlbraw %&gt;% filter(hand == &quot;RvR&quot;) %&gt;% mutate(x = x*-1) %&gt;% mutate(hand = &quot;LvL&quot;)) mlbraw_r_l &lt;- bind_rows(mlbraw %&gt;% filter(hand == &quot;RvL&quot;), mlbraw %&gt;% filter(hand == &quot;LvR&quot;) %&gt;% mutate(x = x*-1) %&gt;% mutate(hand = &quot;RvL&quot;)) mlbraw_l_r &lt;- bind_rows(mlbraw %&gt;% filter(hand == &quot;LvR&quot;), mlbraw %&gt;% filter(hand == &quot;RvL&quot;) %&gt;% mutate(x = x*-1) %&gt;% mutate(hand = &quot;LvR&quot;)) mlbraw2 &lt;- bind_rows(mlbraw_r_r, mlbraw_l_l, mlbraw_r_l, mlbraw_l_r) rm(mlbraw_r_r, mlbraw_l_l, mlbraw_r_l, mlbraw_l_r) The same heatmap now shows double the number of observations for each combination of handedness, pitch type, and count. Some combinations still have low number of observations but it’s an improvement over the previous data set before doubling up. plot10 &lt;- mlbraw2 %&gt;% group_by(hand, count, pitch_type) %&gt;% count() %&gt;% ungroup() ggplot(data = plot10, aes(x=pitch_type, y=count))+ geom_tile(aes(fill=n), alpha = 0.5,show.legend = FALSE)+ facet_wrap(~hand, scale=&quot;free&quot;)+ geom_text(aes(x=pitch_type, y=count, label=n))+ scale_fill_gradientn(colours = c(&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;), values = scales::rescale(c(min(plot10$n), quantile(plot10$n, 0.1), max(plot10$n))), guide=&quot;colorbar&quot;) + theme_void()+ theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 8, hjust = 1), axis.text.y = element_text(size = 12, hjust = 0.9), plot.title = element_text(size=20, hjust = 0.5)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
